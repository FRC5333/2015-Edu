package frc.team5333.recyclerush.data;

import edu.wpi.first.wpilibj.ControllerPower;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import frc.team5333.recyclerush.DriveController;
import frc.team5333.recyclerush.Mappings;
import jaci.openrio.module.blackbox.BlackBox;
import jaci.openrio.module.blackbox.BlackBoxContext;
import jaci.openrio.toast.core.StateTracker;
import jaci.openrio.toast.lib.state.RobotState;

import java.util.function.Supplier;

/**
 * The DataRecorder class is used to record statistics about the Robot and it's performance during a match.
 *
 * This uses the BlackBox Toast Module (written by yours truly) to record this data over time and write it to a
 * .csv file, which can then be opened in Excel or exported to a database. In the 2016 Game, all 3 teams here at Curtin
 * will have a class very similar to this one, because Jaci loves data ^3^
 *
 * For examples of graphs and data generated by this class, look inside of the little booklets I handed out.
 *
 * @author Jaci
 */
public class DataRecorder {

    static BlackBoxContext context;
    static boolean started = false;

    /**
     * Initialize the recorder. This sets up all the 'sources' we pull data from, in the form of the Supplier functional
     * interface.
     */
    public static void init() {
        if (started) return;
        started = true;

        // We store a new file per match, so we use the /match command to set the type and number of the current
        // match.
        context = BlackBox.context(MatchDataCommand.MATCH_TYPE + "_" + MatchDataCommand.MATCH_NUM);
        context.add("controller_a", from(Mappings.CONTROLLER::a));
        context.add("controller_b", from(Mappings.CONTROLLER::b));
        context.add("controller_x", from(Mappings.CONTROLLER::x));
        context.add("controller_y", from(Mappings.CONTROLLER::y));
        context.add("controller_bumper_left", from(Mappings.CONTROLLER::leftBumper));
        context.add("controller_bumper_right", from(Mappings.CONTROLLER::rightBumper));
        context.add("controller_stick_left", from(Mappings.CONTROLLER::leftStick));
        context.add("controller_stick_right", from(Mappings.CONTROLLER::rightStick));
        context.add("controller_start", from(Mappings.CONTROLLER::start));
        context.add("controller_select", from(Mappings.CONTROLLER::select));

        context.add("controller_trigger_left", Mappings.CONTROLLER::leftTrigger);
        context.add("controller_trigger_right", Mappings.CONTROLLER::rightTrigger);

        context.add("controller_x_left", Mappings.CONTROLLER::leftX);
        context.add("controller_y_left", Mappings.CONTROLLER::leftY);
        context.add("controller_x_right", Mappings.CONTROLLER::rightX);
        context.add("controller_y_right", Mappings.CONTROLLER::rightY);
        context.add("controller_pov", Mappings.CONTROLLER::pov);

        context.add("mode_disabled", from(() -> { return StateTracker.currentState == RobotState.DISABLED; }));
        context.add("mode_auto", from(() -> { return StateTracker.currentState == RobotState.AUTONOMOUS; }));
        context.add("mode_teleop", from(() -> { return StateTracker.currentState == RobotState.TELEOP; }));

        context.add("motor_left", Mappings.DRIVE_LEFT::get);
        context.add("motor_right", Mappings.DRIVE_RIGHT::get);
        context.add("motor_clamp", Mappings.CLAMP::get);
        context.add("motor_lift", Mappings.LIFT::get);

        PowerDistributionPanel pdp = new PowerDistributionPanel();

        context.add("power_voltage_pdp", pdp::getVoltage);
        context.add("power_voltage_controller", ControllerPower::getInputVoltage);

        context.add("drive_throttle", DriveController::getThrottleScale);
        context.add("drive_locked", from(DriveController::driveLocked));
    }

    /**
     * Tick the recorder, causing a new entry to be added to the timeline
     */
    public static void tick() {
        if (context != null) context.tick();
    }

    /**
     * Converts a boolean (true, false) supplier to a Number supplier (providing 1 or 0)
     */
    public static Supplier<Number> from(Supplier<Boolean> supp2) {
        return () -> { return supp2.get() ? 1 : 0; };
    }

}
